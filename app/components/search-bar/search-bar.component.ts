import {Component, Input, Output, EventEmitter, ElementRef} from 'angular2/core';
import {DAOService} from '../../services/dao.service';
import {SearchCommand, SearchCommandChain, CommandType} from './search-command';

/**
 * This class is a container for the search bar dropdown results 
 */
export class DropdownElement {
  value: string;
  label: string;

  constructor(value:string, label:string) {
    this.value = value;
    this.label = label;
  }
}

/**
 * This is the main search bar component. It holds most of the logic required.
 */
@Component({
	selector: 'search-bar',
    providers: [DAOService, ElementRef],
	templateUrl: 'app/components/search-bar/search-bar.template.html',
    styleUrls: ['app/components/search-bar/search-bar.style.css']
})
export class SearchBar { 
    
    // The search box content
    @Input() 
    searchString: string;
  
    // The hint list
    @Input()
    values: DropdownElement[];
    
    returnAllResults: boolean;
    
    // Hint map
    valuesMap = {};
    
    // The commandChain state machine            
    commandChain: SearchCommandChain;
    
    // The DOM element of the input, used for refocusing on the input after a hint selection   
    inputElem = null;
    
    constructor(private daoService: DAOService) {
        this.searchString = null;          
        this.commandChain = new SearchCommandChain(daoService); 
        this.returnAllResults = true;          
    }
    
    /**
     * Method called when a dorpdown search result is selected. This method replaces the current
     * command (if incomplete/invalid) with the dorpdown value and recomputes the next command
     * results.
     */
    selectItem(value) {

        var dropDown = this.valuesMap[value];

        if (dropDown) {         
 
            var currentValidCommands = this.commandChain.getValidCommandValues();
            
            if (currentValidCommands == null || currentValidCommands.length == 0) {
                this.searchString = dropDown.label + " ";
            }
            else {                                                            
                this.searchString = currentValidCommands.join(' ') + " " + dropDown.label + " ";                               
            }
            
            this.clearValues();
    
            if (this.inputElem != null) {
                this.inputElem.focus();
            }          
            this.handleInput(this.searchString, true);           
        }
    }
    
    /**
     * This method is called when the search box was given a new key.
     */
    onKeyUp(event) {        
        if (this.inputElem == null) {
             this.inputElem = event.target; 
        }                              
        this.handleInput(this.searchString, true);                     
    }
    
    /**
     * Method called when a key is pressed, but before it was release, thus allowing us to
     * intercept it and make some checks to the intput. This way we can prohibit keys which
     * would not result in any dropdown items. 
     * 
     * NOTE: The space character is not prohibited.
     */
    onKeyDown(event) {
                
        var strToCheck = null;
        
        var key;
        var origKey;        
        if (event.key) {
            key = event.key.toLowerCase();
        }
        else if (event.code) {                     
          /** Chrome fix: Check for getting key another way, Chrome does not 
           *   use 'key' property in their events  
           */       
           key = event.code.replace("Key", "").toLowerCase();
        }
  
        origKey = key;

        if (key.length > 1) {
            key = "";
        }
        
        if (this.searchString == null) {
            strToCheck = key;
        }
        else {
            strToCheck = this.searchString + key;
        }

        var result = this.handleInput(strToCheck, false);
  
        if (result == null && !(origKey == "backspace" || origKey == "delete" || origKey == "arrowright" || origKey == "arrowleft")) {            
            event.preventDefault();   
        }                      
    }
    
    /**
     * This is the main method which deals with validating the search box content and
     * providing the search hints to the current command.
     * 
     * @textLine: this is the input to validate
     * @clearValue: flag for determining whether or not to clear the current dropdown hints
     *              used by the character inhibition call, so that if a character is invalid, we
     *              dont clear the hints, and this way we can reuse the code
     * 
     * @return: returns the search results generated by the given textLine,
     *          null if no results were found 
     */
    private handleInput(textLine: string, clearValue: boolean): string [] {
              
        if (clearValue) {
             this.clearValues();
        }      
       
        var commandStrings = SearchBar.getCommandStrings(textLine);

        if (commandStrings == null) {
            return;
        }

        this.commandChain.populate(commandStrings);       
        var currentCommand = this.commandChain.currentCommand;
        
        if (currentCommand == null) {
            return;
        }
        
        var searchStr = currentCommand.value;

        var result = null;
        
        if (currentCommand.type == CommandType.action) {
            if (currentCommand.isValid) {
                 result = this.daoService.getItems(currentCommand.value, this.getEmptySearchItem());
            }
            else {
                result = this.daoService.getActions(searchStr);
            }                                                      
        }
        else if (currentCommand.type == CommandType.item) {
            if (currentCommand.isValid) {
                result = this.daoService.getProperties(this.commandChain.item.value, this.getEmptySearchItem()); 
            }  
            else {
                 result = this.daoService.getItems(this.commandChain.action.value, searchStr);  
            }                                    
        }
        else if (currentCommand.type == CommandType.property) {                
            result = this.daoService.getProperties(this.commandChain.item.value, searchStr);         
        }
        else if (currentCommand.type == CommandType.price) {
            if (this.daoService.isPriceValid(this.commandChain.price.value)) {
               result = [];
            }        
        }
        else if (currentCommand.type == CommandType.end) {
            result = null;
        }
          
        if (clearValue) {
            this.populateChoices(result, searchStr);
        }
        
        return result;  
    }
    
    private getEmptySearchItem(): string {
        if (this.returnAllResults) {
            return "";
        }
        else {
            return null; 
        }
    }
    
    /**
     * Populate the dropdown hints
     */
    private populateChoices(result: string[], searchStr: string): void {
        if (result != null && !(result.length == 1 && result[0] == searchStr)) {   
                   
            for (var i = 0, len = result.length; i < len; i++) {
                var key = "key" + i;
                var dropDown = new DropdownElement(key, result[i]);
                this.valuesMap[key] = dropDown;
                this.values.push(dropDown);
            }          
        }      
    }    
        
    /**
     * Clears the dropdown hints
     */
    private clearValues() {
        this.values = [];
        this.valuesMap = {};
    }
    
    /**
     * This method takes the given string and splits it into words, ignoring any extra whitespaces
     *  
     * NOTE: Whenever I can I try to decouple utility methods from the object (no this. references) 
     *       in case I want to refactor it later into a separate Util class
     */
    private static getCommandStrings(input: string): string []  {

        if (input == null || input == "") {
            return null;
        }
           
        var tokens = input.split(' ');
        
        if (tokens == null || tokens.length < 1) {
            return null;
        }
        
        var commandStrings = null;    
        
        // Get command strings only, get rid of whitespace
        for (var i = 0, len = tokens.length, token; i < len; i++) {
             token = tokens[i];            
             if (token == null) {
                continue;
             }
             token = token.trim();
             if (token === '' || token === ' ') {
                 continue;
             }
             
             if (commandStrings == null) {
                commandStrings = []; 
             }
             commandStrings.push(token);              
        }
        
        return commandStrings;
    }   
}
